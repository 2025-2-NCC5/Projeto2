# -*- coding: utf-8 -*-
"""Entrega 1 - Inteligência Artifical e Aprendizado de Máquina .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1prkKCOfAvvMmefjSS6Q0tpTlXGAVGXBX

### Explicação da célula 1
Esse código está preparando um ambiente de programação para a análise de dados e modelagem estatística, focando especificamente em modelos de regressão logística. As bibliotecas e os pacotes importados servem como um kit de ferramentas, onde cada um tem uma função específica para o processo de análise.
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib inline

import statsmodels.api as sm
import statsmodels.formula.api as smf
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import roc_auc_score, roc_curve, classification_report,\
                            accuracy_score, confusion_matrix, auc

"""### Explicação da célula 2
Este código carrega um arquivo CSV dairetamente do no seu github onde tem os dados da cannoli e o exibe no console
- Carregamento do dataset em um DataFrame.

"""

data = pd.read_csv('https://raw.githubusercontent.com/2025-2-NCC5/Projeto2/main/cannoli.csv')
print(data.to_string())

"""### Explicação da célula 3

Esse código define uma função em Python chamada freq que calcula a frequência absoluta e percentual de valores em uma série do pandas.



"""

def freq(x: pd.Series, plot=False):
    contagem = x.value_counts(dropna=False)
    percentual = round((contagem / x.shape[0]) * 100, 3)

    res = pd.DataFrame({'n': contagem, 'perc': percentual})
    res.index.name = 'values'

    if plot:
        sns.countplot(x)
        plt.show()

    return res

"""### Explicação da célula 4

Esse código Python que você forneceu calcula a distribuição percentual dos valores na coluna.

"""

(data.gender.value_counts() / data.shape[0]) * 100

"""### Explicação da célula 5
Esse código que você forneceu é uma função Python chamada freq. O objetivo dela é calcular e exibir a frequência de valores em uma série de dados, como uma coluna em uma tabela.

"""

freq(data.gender, plot=True)

"""### Explicação da célula 6
Esse código Python que você forneceu é utilizado para criar um gráfico de barras que visualiza a contagem dos valores na coluna status de um conjunto de dados.

"""

contagem_status = data['status'].value_counts()

contagem_status.plot(kind='bar', rot=0)

plt.title('Contagem de Status (0 e 1)')
plt.xlabel('Status')
plt.ylabel('Contagem')
plt.show()

"""### Explicação da célula 7
Esse codigo gera um resumo estatístico da coluna taxid para uma análise exploratória de dados do pandas.
"""

data.taxid.describe()

"""### Explicação da célula 8
Esse código cria um gráfico de box plot, que é uma visualização útil para comparar a distribuição de uma variável numérica (taxid) entre diferentes grupos (gender).

"""

sns.boxplot(x='gender', y='taxid', data=data)
plt.title('Distribuição de id por sexo')
plt.show()

"""### Explicação da célula 9
Esse codigo converte o tipo de dado da coluna 'status' do seu DataFrame para a categoria category. Para a otimização de memória e melhoria de desempenho

"""

data['status'] = data['status'].astype('category')

"""### Explicação da célula 10
 Esse código ajusta um modelo de regressão logística para entender como as variáveis gender e isenriched influenciam o status e, em seguida, imprime um relatório estatístico detalhado sobre esses relacionamentos.
"""

modelo = smf.glm(formula='status ~ gender + isenriched', data=data,
                 family=sm.families.Binomial()).fit()
print(modelo.summary())

"""### Explicação da célula 11
Esse código pega os coeficientes do seu modelo, converte-os em odds ratios e os exibe, tornando os resultados muito mais fáceis de interpretar e comunicar.

"""

print(np.exp(modelo.params[1:]))

"""### Explicação da célula 12
O código (np.exp(modelo.params[1:]) - 1) * 100 transforma os odds ratios do seu modelo de regressão em variação percentual. Essa forma de interpretar os resultados é muito mais intuitiva do que os odds ratios ou os próprios coeficientes, pois ela expressa o impacto de cada variável de forma clara e direta.



"""

(np.exp(modelo.params[1:]) - 1) * 100

"""### Explicação da célula 13
Em resumo, esse código mostra o ciclo completo de preparação de dados para um modelo de regressão logística e, crucialmente, demonstra como garantir que novos dados estejam no formato exato que o modelo espera para realizar uma previsão.

"""

y = data['status']
X = pd.get_dummies(data[['gender', 'isenriched']], drop_first=True)

model = LogisticRegression(penalty=None, solver='newton-cg')
model.fit(X, y)

colunas_treino = X.columns

novo_registro = pd.DataFrame({
    'gender': ['F'],
    'isenriched': [1]
})

novo_registro_dummies = pd.get_dummies(novo_registro, drop_first=True)
novo_registro_alinhado = novo_registro_dummies.reindex(columns=colunas_treino, fill_value=0)

"""### Explicação da célula 14
Em essência, a linha model.fit(X, y) faz com que o modelo analise os dados em X e y para encontrar a melhor relação entre eles.

"""

model.fit(X, y)

"""### Explicação da célula 15

Essa parte é a representação de um modelo de Regressão Logística com todos os seus parâmetros padrão

"""

LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True,
                   intercept_scaling=1, l1_ratio=None, max_iter=100,
                   multi_class='warn', n_jobs=None, penalty='none',
                   random_state=None, solver='newton-cg', tol=0.0001, verbose=0,
                   warm_start=False)

"""### Explicação da célula 16
O codigo exibe os coeficientes do seu modelo de regressão logística após ele ter sido treinado.

"""

print(model.coef_)

"""### Explicação da célula 17

O código yhat = model.predict_proba(X) faz com que o seu modelo de regressão logística calcule as probabilidades de cada registro em X pertencer a cada uma das classes da sua variável alvo (y).

"""

yhat = model.predict_proba(X)

"""### Explicação da célula 18
O código yhat = model.predict(novo_registro_alinhado) utiliza o seu modelo de machine learning treinado para fazer uma previsão para o novo registro de dados.



"""

yhat = model.predict(novo_registro_alinhado)
print(yhat)

"""# Metrica

### Explicação da célula 19

O código confusion_matrix(y, model.predict(X)) é usado para avaliar o desempenho do seu modelo de classificação criando uma matriz de confusão.
"""

confusion_matrix(y, model.predict(X))

"""### Explicação da célula 21

O código pd.crosstab(y, model.predict(X)) cria uma tabela de contingência que, na prática, funciona como uma matriz de confusão.



"""

pd.crosstab(y, model.predict(X))

"""### Explicação da célula 22
O código ac = accuracy_score(y, model.predict(X)) calcula a acurácia do seu modelo de classificação.



"""

ac = accuracy_score(y, model.predict(X))
ac

"""### Explicação da célula 23
O código print(classification_report(y, model.predict(X))) gera um relatório completo de avaliação para o seu modelo de classificação. Ele é uma ferramenta mais detalhada e útil do que apenas a acurácia.



"""

print(classification_report(y, model.predict(X)))

"""### Explicação da célula 24

O código calcula o escore AUC (Área Sob a Curva ROC), que é uma métrica de avaliação muito comum para modelos de classificação binária.


"""

yhat_prob = model.predict_proba(X)
auc_score = roc_auc_score(y, yhat_prob[:, 1])

print('AUC: %0.8f' % auc_score)

"""### Explicação da célula 25
Essa função Python, chamada plot_roc_curve, é usada para criar e exibir um gráfico de Curva ROC (Receiver Operating Characteristic). Ela visualiza a capacidade do seu modelo de classificação binária de distinguir entre as classes.



"""

def plot_roc_curve(y_true, y_score, figsize=(10,6)):
    fpr, tpr, _ = roc_curve(y_true, y_score)
    plt.figure(figsize=figsize)
    auc_value = roc_auc_score(y_true, y_score)
    plt.plot(fpr, tpr, color='orange', label='ROC curve (area = %0.6f)' % auc_value)
    plt.plot([0, 1], [0, 1], color='darkblue', linestyle='--')
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('Receiver Operating Characteristic (ROC) Curve')
    plt.legend()
    plt.show()

"""### Explicação da célula 26

O código utiliza o seu modelo de regressão logística para gerar as probabilidades de previsão e, em seguida, usa a função que você definiu anteriormente para plotar a curva ROC e calcular o seu escore AUC.



"""

yhat = model.predict_proba(X)[:, 1]
plot_roc_curve(y, yhat)

"""### Explicação da célula 27
O código pega um novo registro de dados e usa seu modelo de machine learning para prever a probabilidade de o status ser 1. Em seguida, ele formata e exibe essa probabilidade de uma forma mais legível.



"""

prob = model.predict_proba(novo_registro_alinhado)
print('A probabilidade de o status ser 1 é de {}%'.format(round(prob[0, 1] * 100, 2)))